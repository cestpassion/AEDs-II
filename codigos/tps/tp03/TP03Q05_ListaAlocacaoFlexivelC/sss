#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Estrutura para armazenar informações do Pokemon
typedef struct Pokemon
{
    int id;
    int generation;
    char *name;
    char *description;
    char **types;
    char **abilities;
    double weight;
    double height;
    int captureRate;
    char *isLegendary;
    char *date;
} Pokemon;

// Tipo Celula
typedef struct Celula
{
    Pokemon pokemon;     // Elemento inserido na celula.
    struct Celula *prox; // Aponta a celula prox.
} Celula;

Celula *newCelula(Pokemon pokemon)
{
    Celula *new = (Celula *)malloc(sizeof(Celula));
    new->pokemon = pokemon;
    new->prox = NULL;
    return new;
}

// Construtor da classe que cria uma lista sem elementos
typedef struct FlexList
{
    Celula *primeiro;
    Celula *ultimo;
} FlexList;

// Função para inicializar e alocar os atributos
void start(PokemonStorage *storage, FlexList *list)
{
    storage->tamPokStorage = 0;
    storage->pokStorage = (Pokemon *)malloc(1 * sizeof(Pokemon));

    Pokemon emptyPokemon = {0, 0, NULL, NULL, NULL, NULL, 0.0, 0.0, 0, NULL, NULL};
    list->primeiro = newCelula(emptyPokemon);
    list->ultimo = list->primeiro;
}

// -----------------------------
// LISTA FLEXÍVEL: Início
// -----------------------------

// INSERIR:
// Função para inserir no início da Lista Flexível
void inserirInicio(FlexList *list, Pokemon pokemon)
{
    Celula *tmp = newCelula(pokemon);

    tmp->prox = list->primeiro->prox;
    list->primeiro->prox = tmp;

    if (list->primeiro == list->ultimo)
        list->ultimo = tmp;

    tmp = NULL;
}

// Função para inserir no fim da Lista Flexível
void inserirFim(FlexList *list, Pokemon pokemon)
{
    list->ultimo->prox = newCelula(pokemon);
    list->ultimo = list->ultimo->prox;
}

int sizeFlexList(FlexList list)
{
    int size = 0;
    for (Celula *i = list.primeiro; i != list.ultimo; i = i->prox, size++);

    return size;
}

// Função para inserir na p-ésima posição  da Lista Flexível
void inserir(FlexList *list, Pokemon pokemon, int pos)
{
    int size = sizeFlexList(*list); /* O ponteiro (*) na chamada da função serve para desreferenciar
                                    o ponteiro list, convertendo-o de um ponteiro para uma estrutura
                                    FlexList em uma estrutura FlexList direta. */
    if (pos < 0 || pos >= size)
    {
        printf("Erro! Posição inválida.\nPosicoes validas = 0 a %d\nPosicao inserida = %d\n", size, pos);
        exit(1);
    }
    else if (pos == 0)
    {
        inserirInicio(list, pokemon);
    }
    else if (pos == size)
    {
        inserirFim(list, pokemon);
    }
    else
    {
        // Caminhar ate a posicao anterior a insercao
        Celula *i = list->primeiro;
        for (int j = 0; j < pos; j++, i = i->prox);

        Celula *tmp = newCelula(pokemon);

        tmp->prox = i->prox;
        i->prox = tmp;
        tmp = i = NULL;
    }
}

// REMOVER:
// Função para remover no início da Lista Flexível
Pokemon removerInicio(FlexList *list)
{
    if (list->primeiro == list->ultimo)
    {
        printf("Erro! Não há pokemons para remover.\n");
        exit(1);
    }

    Celula *tmp = list->primeiro;
    list->primeiro = list->primeiro->prox;
    Pokemon removedPokemon = list->primeiro->pokemon;
    free(tmp);

    return removedPokemon;
}

// Função para remover no fim da Lista Flexível
Pokemon removerFim(FlexList *list)
{
    if (list->primeiro == list->ultimo)
    {
        printf("Erro! Não há pokemons para remover.\n");
        exit(1);
    }

    Celula *i;
    for (i = list->primeiro; i->prox != list->ultimo; i = i->prox);
    
    Pokemon removedPokemon = list->ultimo->pokemon;
    list->ultimo = i;
    i = list->ultimo->prox = NULL;  

    return removedPokemon;
}

// Função para remover na p-ésima posição da Lista Flexível
Pokemon remover(FlexList *list, int pos)
{
    int size = sizeFlexList(*list);
    Pokemon removedPokemon;

    if (list->primeiro == list->ultimo)
    {
        printf("Erro! Não há pokemons para remover.\n");
        exit(1);
    }
    else if (pos < 0 || pos >= size)
    {
        printf("Erro! Posição inválida.\nPosicoes validas = 0 a %d\nPosicao inserida = %d\n", size, pos);
        exit(1);
    }
    else if (pos == 0)
    {
        removedPokemon = removerInicio(list);
    }
    else if (pos == size - 1)
    {
        removedPokemon = removerFim(list);
    }
    else
    {
        // Caminhar ate a posicao anterior a insercao
        Celula *i = list->primeiro;
        int j;
        for (j = 0; j < pos; j++, i = i->prox);

        Celula *tmp = i->prox;
        removedPokemon = tmp->pokemon;
        i->prox = tmp->prox;

        tmp->prox = NULL;
        i = tmp = NULL;
    }
    return removedPokemon;
}

// MOSTRAR:
// Função para imprimir os pokemon presentes na Lista Flexível
void mostrar(FlexList list)
{
    int size = sizeFlexList(list);
    Celula *i = list.primeiro;

    for (int j = 0; j < size; j++, i = i->prox)
    {
        printf("[%d] ", j);
        imprimir(i->pokemon);
    }
}

// -----------------------------
// LISTA FLEXÍVEL: Fim
// -----------------------------

// FUNÇÃO PRINCIPAL
int main()
{
    PokemonStorage storage;
    FlexList list;

    start(&storage, &list);
    ler(&storage);

    char input[50];

    scanf("%s", input);
    while (strcmp(input, "FIM") != 0)
    {
        inserirFim(&list, searchIdStorage(storage, atoi(input)));
        scanf("%s", input);
    }

    int operations; // quantidade de registros a serem inseridos/removidos
    int cont = 0;
    int infos = 0;
    char *pch;
    char subString[3][10];

    scanf("%d", &operations);
    getchar();

    while (cont < operations)
    {
        infos = 0;

        scanf("%[^\n]", input);
        getchar();

        pch = strtok(input, " ");
        while (pch != NULL)
        {
            strcpy(subString[infos], pch); // atribui o tipo tokenizado
            pch = strtok(NULL, " ");
            infos++;
        }

        if (strcmp(subString[0], "II") == 0)
        {
            inserirInicio(&list, searchIdStorage(storage, atoi(subString[1])));
        }
        else if (strcmp(subString[0], "IF") == 0)
        {
            inserirFim(&list, searchIdStorage(storage, atoi(subString[1])));
        }
        else if (strcmp(subString[0], "I*") == 0)
        {
            inserir(&list, searchIdStorage(storage, atoi(subString[2])), atoi(subString[1]));
        }
        else if (strcmp(subString[0], "RI") == 0)
        {
            printf("(R) %s\n", removerInicio(&list).name);
        }
        else if (strcmp(subString[0], "RF") == 0)
        {
            printf("(R) %s\n", removerFim(&list).name);
        }
        else if (strcmp(subString[0], "R*") == 0)
        {
            printf("(R) %s\n", remover(&list, atoi(subString[1])).name);
        }
        cont++;
    }
    mostrar(list);

    // Liberação da memória alocada
    free(storage.pokStorage);
    free(list.primeiro);
    free(list.ultimo);
}